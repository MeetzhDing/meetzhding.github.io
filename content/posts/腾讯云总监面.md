---
title: 腾讯云总监面
date: 2019-04-19 19:08:40
tags:
---

等了无穷久，等到了面试，一共43分钟，面试的一塌糊涂。
原本以为会问一些后端的内容，结果后端的内容提都没有提过...
感觉总监是照着某个面试文档来面试的，总是想要我讲的特别详细，比如某个头的名字等
最后问自己是否通过，总监说要暂时不能给答复，等了一天最终还是通过了。

<!--more-->
## 常规性问题
1. 自我介绍
2. 为什么做前端
3. 介绍一个自己的项目
4. 职业生涯规划
5. 你有什么想问我

---
## https安全性
连上黑客的wifi，能够保证安全吗？
答案是能够保证安全的，但是可能由于用户安全意识不强造成信息泄露。

https的连接过程如下
①客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。
②服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。
③客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。
④用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。
⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。
⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。
⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。
⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。
⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。
⑩SSL的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

![单向连接过程](https://github.com/MeetzhDing/Meetzhding.github.io/blob/Blog/picture/单向认证.jpeg?raw=true)

从图中我们可以看到，https建立的时候，传递的证书信息，公钥信息都是公开的，中间人可以直接获取，此时中间人可以截留此部分信息，伪造证书发送给客户端。
当客户端浏览器收到了相关内容以后进行校验后就能够发现证书是伪造的，将会对用户给出提醒，但是如果用户坚持访问，那么中间人攻击就得逞了。
在这个过程中，由于客户端拿到的证书是中间人的证书，所以相关的信息都能够被中间人解密，中间人可以再使用从服务器端拿到的证书进行加密并发送给服务端，服务端最终校验合法。
此时我们注意到，服务端完全没有意识到发生了中间人攻击，那么也就没有理由拒绝由中间人发送来的请求，从而产生更大的危害。

还有一些情况下，认证的双方都需要证明自己的身份，这个时候就需要用到https的双向连接方式，客户端也需要向服务器发送自己的证书与公钥，用于服务端验证。
![双向连接过程](https://github.com/MeetzhDing/Meetzhding.github.io/blob/Blog/picture/双向认证.jpeg?raw=true)

参考信息网址：[图解https单向认证和双向认证](https://kuaibao.qq.com/s/20180606A09NKT00?refer=cp_1026)

---
## 前端性能优化
我自己说了一些方法，然后面试官问的有些问题让我觉得有点奇怪。
### 为什么js需要放到文档末尾
浏览器渲染过程中，如果遇到script标签就停止渲染，执行JS代码。因为浏览器有GUI渲染线程与JS引擎线程，为了防止渲染出现不可预期的结果，这两个线程是互斥的关系。JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是都建议将script标签放在body标签底部的原因。当然在当下，并不是说script标签必须放在底部，因为你可以给script标签添加defer或者async属性。


### CDN降低延迟
面试官问我为什么CDN更好，我说可以减少同一个域的请求数目，也不用有cookie的性能损耗。
`
面试官非要问我为什么CDN不带cookie，带不带cookie和CDN有什么关系呢？
`
上面这个问题问了好多遍，我说就是不会传，cookie是用来鉴权的，同源策略。但是面试官总是再次重新问一遍这个问题
我现在猜想面试官想要我说的可能是 使用无cookie的域，就是对cookie的domain进行解释。


### 占位图与懒加载
面对首屏优化问题，更希望能够快速将内容的整体结构展现给用户，使用占位图，可以直接替代真实图片的所在位置，保证整体界面的布局和渲染完成后一致。
当真正需要显示的图片加载完成以后，就可以直接替换相应的图片，由于占位图的尺寸和最终图片一致，只会触发重绘而不会触发回流，性能更好。

懒加载方法是指，对于网页中没有显示的部分，先不进行加载，等到用户继续翻阅需要的时候，才从网络中进行加载，可以达到节省用户流量与提高网页性能的效果。
懒加载的实现原理是先不给图片的src赋值，使用一个自定义属性比如data-src，对图片是否显示在用户屏幕上进行判断（判断的方法比较多），当需要显示这张图片的时候，加载图片，进行显示。

如何判断图片是否应当显示呢？
使用方法 window.pageYOffset与window.pageXOffset，结合window.innerWidth和window.innerHeight判断所处位置，
也可以通过监听scroll事件，判断滚动的距离，配合上原本的位置信息，得到窗口现在的位置信息。
获取到窗口的位置信息以后，可以根据图片元素的offsetTop与offsetLeft属性进行判断，如果发现有重合现象，就进行加载。

浏览器的新API： IntersectionObserver，交叉探索器（chrome51+），元素在出现和离开视口区的时候都会调用callback，可以进行相应的操作。

也可以使用一些第三方的库，有些直接帮助你进行懒加载操作，比较方便，例如LazyLoad。


### 合并请求的系列方法
针对小文件而言，在传输过程，如果使用多个请求，那么每个请求都需要去完成TCP连接，慢启动等过程，可能会造成较高的时延。浏览器往往也会有并发数的限制，当资源加载队列内容多的时候，变得更加缓慢。所以有一类常用的方法，尽可能的将外部的脚本、样式进行合并，多个合为一个。 CSS Sprites方式合并CSS图片其实也是一种资源合并的方法。

对于大资源，是否合并对于加载时间没有明显影响，但拆分资源可以更好的利用浏览器缓存，不会因为某个资源的更新导致所有资源缓存失效，而资源合并后，任一资源的更新都会导致整体资源的缓存失效。
对于小资源，合并资源往往具有更快的加载速度，但在网络带宽状况良好的情况下，因为提升的时间单位以ms计量，收益可以忽略。如果网络延迟很大，服务器响应速度又慢，则可以带来一定收益，但在高延迟的网络场景下，又要注意合并资源后可能带来网络往返次数的增加，进而影响到加载时间。

---
## HTTP相关问题

### 浏览器缓存
主要有强缓存和协商缓存
有关缓存的内容参考文章[HTTP 强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)

### get和post有什么区别
[GET和POST区别](https://www.jianshu.com/p/fd67b576365d)
[关于Http协议，你必须要知道的](https://juejin.im/post/5b1e93aa5188257d3914280e)

### http2
二进制传输：每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。
多路复用：解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。
头部压缩：使用 “首部表” 来跟踪和存储之前发送的键值对，对于相同的数据，后续请求和响应无需重复发送，只需要发送变化的内容即可。
服务端推送：提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间，例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。

### http3（QUIC）
HTTP/2使用了多路复用，一般来说同一域名下只需要使用一个TCP连接。但当这个连接中出现了丢包的情况，那就会导致HTTP/2的表现情况反倒不如HTTP/1了，因为在出现丢包的情况下，整个TCP都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于HTTP/1.1来说，可以开启多个TCP连接，出现这种情况反到只会影响其中一个连接，剩余的TCP连接还可以正常传输数据。

0RTT建立连接：建立在UDP的基础上，同时又实现了0RTT的安全握手，所以在大部分情况下，只需要0个RTT就能实现数据发送。
多路复用：基于UDP，一个连接上的多个stream之间没有依赖。某个流中丢了一个UDP包，不会影响后面跟着其他流传输，不存在TCP的队头阻塞问题。且不同于TCP使用IP和端口来识别连接，QUIC直接通过ID方式识别一个连接，可以减少网络环境导致的问题。
加密认证的报文：TCP协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。QUIC除了个别报文比如PUBLIC_RESET和CHLO，所有报文头部都是经过认证的，报文Body都是经过加密的。
向前纠错机制：每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间 (包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗)

有关HTTP/2和HTTP/3的相关信息可参考[一文读懂HTTP/2及HTTP/3特性](https://segmentfault.com/a/1190000018401534)

---
## 其他问题
### 浏览器如何设置cookie
document.cookie="key=val; expires=***"
删除一个cookie的方式为再次设置这个cookie，同时将过期时间设为从前的时间，例如当前时间减1。

### 前端跨域，解决方案
说了jsonp和CORS
[九种跨域方式实现原理](https://juejin.im/post/5c23993de51d457b8c1f4ee1)

### 图片如何上下左右居中
比较常见的方法是使用flex布局搭配justify-content:center，align-self:center
[如何居中一个元素](https://juejin.im/post/5bc3eb8bf265da0a8a6ad1ce)
