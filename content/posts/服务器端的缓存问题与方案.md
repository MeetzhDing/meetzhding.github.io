---
title: 服务器端的缓存问题与方案
date: 2019-04-15 16:38:33
tags:
---

互联网的一些高并发，高性能的项目和系统中，缓存技术是起着功不可没的作用。

在缓存的应用中，有着以下比较常见的问题，这里对常见的方案做一个总结。
- 缓存穿透
- 缓存雪崩
- 高并发

<!--more-->
---

## 缓存穿透
缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决办法：
1. 查询内容的格式校验
对于用户的请求，就是先进行简单的判断，如果请求的内容符合格式要求，再进一步在缓存中查询。但是这种方式对于防范攻击的意义不大，因为攻击者可以提前调查API请求格式。
2. IP的过滤处理
对于一个频繁的请求，攻击者可能使用了固定的IP或一个IP池进行访问，程序中进行检测并且一段时间内对IP进行封禁也可以减少服务器压力。
3. 布隆过滤器
布隆过滤器的原理其实很简单，维护一个长数组(或bitmap)，默认值都为0。预先设计K个hash函数，对于每一个正常的key值，都去进行K次哈希，再变换后得到一个数组的索引，让数组的对应项置1。
当有一个查询请求来到的时候，使用这些hash函数进行处理，查询数组中的对应项是否为1，如果某一项不是1，那么代表着这个查询项不存在，这次请求就不会对缓存和数据库造成压力了。
但是需要注意的是，当某一个key对应的所有项都是1的时候，不代表该项一定存在与缓存与数据库中。
布隆过滤器有一个明显的缺点，就是不支持删除操作，当想要去除某一个key的时候，不能够直接设置相应的项内容为0，因为这将会导致其他的项的判定失效。
可以使用改进后的布隆过滤器，数组中存储的是一个数字，代表所有的key的哈希函数项为此索引的个数，当删除一个key的时候，只要让所有的项都减去1就好了。
4. 短时缓存空对象方式(可搭配二级缓存方案)
可以采用一个简单粗暴的方法，如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
短时缓存方案不能够解决大量的无效随机访问，因为在创建空对象之前，先至少需要查询一次数据库。
缓存空对象会有两个问题：
第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。
第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，因此使用此方法时，需要在程序实现中进行兼容。

<br>

## 缓存雪崩
当缓存服务器重启或者大量缓存集中在某一个时间段失效，会给后端系统(比如DB)带来很大压力，造成数据库后端故障，从而引起应用服务器雪崩。

### 雪崩效应产生的几种场景：
- 流量激增：比如异常流量、用户重试导致系统负载升高。
- 热点缓存失效：某热点Key时刻都有着大量的访问，如微博热搜，当缓存中此key的过期时间到达后，大量并发涌入查询同一个key，造成数据库压力大。
- 缓存失效：程序加载方式等不合理，或巧合下导致过期时间设置相同，同一时间有大量key失效。
- 程序有Bug：代码循环调用的逻辑问题，资源未释放引起的内存泄漏等问题；
- 硬件故障：比如宕机，机房断电，光纤被挖断等。
- 数据库严重瓶颈，比如：长事务、sql超时等。

### 缓存雪崩的解决方案：
(1) 避免缓存集中失效，不同的key设置不同的超时时间，缓存有效时间随机化，避免同时失效。
(2) 增加互斥锁，控制数据库请求，避免对数据库的并发查询过多。
(3) 监控即将失效的缓存，或新请求到来延长缓存有效时间。
(4) 提高缓存的高可用性，如：redis集群。

对于下层服务的保护(防止局部压力过大)：
#### 熔断模式
这种模式参考了电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。
某个目标服务调用慢或大量超时，则熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。直到目标服务情况好转，恢复调用。
此方式主要通过监视机器性能指标实现，尤其需要监控数据库的长事务，sql超时情况。

在熔断的设计主要参考了hystrix的做法。其中最重要的是三个模块：熔断请求判断算法、熔断恢复、熔断报警:
(1) 熔断请求判断机制算法：使用无锁循环队列计数，每个熔断器默认维护10个bucket，每1秒一个bucket，每个blucket记录请求的成功、失败、超时、拒绝的状态，默认错误超过50%且10秒内超过20个请求进行中断拦截。
(2) 熔断恢复：对于被熔断的请求，每隔5s允许部分请求通过，若请求都是健康的(RT<250ms)则对请求健康恢复。
(3) 熔断报警：对于熔断的请求打日志，异常请求超过某些设定则报警。

#### 隔离模式
例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。

隔离的方式一般使用两种
(1) 线程池隔离模式：使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量(流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理)
(2) 信号量隔离模式：使用一个原子计数器(或信号量)来记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃改类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量(流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务)

#### 限流模式
熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。
限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。
这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。

<br>

## 高并发问题
高并发的情况有很多种，要结合并发请求的基本情况来处理
常见的解决方案有：
- redis缓存
- 数据库分库分表
- 数据库读写分离(多种主从同步策略)
- 数据库分布式高可用

---

<br>

本文参考内容如下：
[缓存穿透,瞬间并发,缓存雪崩的解决方法](https://blog.csdn.net/fei33423/article/details/79027790)
[什么是缓存雪崩？服务器雪崩的场景与解决方案](https://blog.csdn.net/gupao123456/article/details/82708762)
[常用场景下缓存穿透，缓存雪崩，缓存并发处理策略](https://blog.csdn.net/chenaima1314/article/details/79051916)
[最全面的缓存架构设计](https://blog.csdn.net/zjttlance/article/details/80234341)